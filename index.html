<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>RSchema by tomdalling</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>RSchema</h1>
        <h2>Schema-based validation and coercion for Ruby data structures</h2>
        <a href="https://github.com/tomdalling/rschema" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="rschema" class="anchor" href="#rschema" aria-hidden="true"><span class="octicon octicon-link"></span></a>RSchema</h1>

<p>Schema-based validation and coercion for Ruby data structures. Heavily inspired
by (read: stolen from) <a href="https://github.com/Prismatic/schema">Prismatic/schema</a> for Clojure.</p>

<h2>
<a id="meet-rschema" class="anchor" href="#meet-rschema" aria-hidden="true"><span class="octicon octicon-link"></span></a>Meet RSchema</h2>

<p>A "schema" is a data structure that describes the <em>shape</em> of data.
Schemas are generally just plain old hashes, arrays, and classes.</p>

<div class="highlight highlight-ruby"><pre>post_schema <span class="pl-k">=</span> {
  <span class="pl-c1">title:</span> <span class="pl-vo">String</span>,
  <span class="pl-c1">tags:</span> [<span class="pl-vo">Symbol</span>],
  <span class="pl-c1">body:</span> <span class="pl-vo">String</span>
}</pre></div>

<p>Schemas can be used to validate data. That is, they can check whether
data is in the correct shape:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-s3">RSchema</span>.validate(post_schema, {
  <span class="pl-c1">title:</span> <span class="pl-s1"><span class="pl-pds">"</span>You won't beleive how this developer foo'd her bar<span class="pl-pds">"</span></span>,
  <span class="pl-c1">tags:</span> [<span class="pl-c1">:foos</span>, <span class="pl-c1">:bars</span>, <span class="pl-c1">:unbeleivable</span>],
  <span class="pl-c1">body:</span> <span class="pl-s1"><span class="pl-pds">'</span>&lt;p&gt;blah blah&lt;/p&gt;<span class="pl-pds">'</span></span>
}) <span class="pl-c">#=&gt; true</span></pre></div>

<h2>
<a id="what-is-a-schema" class="anchor" href="#what-is-a-schema" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is a schema?</h2>

<p>Schemas are Ruby data structures. The simplest type of schema is just a class:</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> <span class="pl-vo">Integer</span>
<span class="pl-s3">RSchema</span>.validate(schema, <span class="pl-c1">5</span>) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, <span class="pl-s1"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span>) <span class="pl-c">#=&gt; false</span></pre></div>

<p>Then there are composite schemas, which are schemas composed of subschemas.
Arrays are composite schemas:</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> [<span class="pl-vo">Integer</span>]
<span class="pl-s3">RSchema</span>.validate(schema, [<span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">12</span>]) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, [<span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-s1"><span class="pl-pds">'</span>12<span class="pl-pds">'</span></span>]) <span class="pl-c">#=&gt; false</span></pre></div>

<p>And so are hashes:</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> { <span class="pl-c1">fname:</span> <span class="pl-vo">String</span>, <span class="pl-c1">age:</span> <span class="pl-vo">Integer</span> }
<span class="pl-s3">RSchema</span>.validate(schema, { <span class="pl-c1">fname:</span> <span class="pl-s1"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>, <span class="pl-c1">age:</span> <span class="pl-c1">27</span> }) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, { <span class="pl-c1">fname:</span> <span class="pl-s1"><span class="pl-pds">'</span>Johnny<span class="pl-pds">'</span></span> }) <span class="pl-c">#=&gt; false</span></pre></div>

<p>While schemas are just plain old Ruby data structures, RSchema also provides
an extensible DSL for constructing more complicated schemas:</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema {{
  <span class="pl-c1">fname:</span> predicate { |<span class="pl-vo">n</span>| n.is_a?(<span class="pl-vo">String</span>) <span class="pl-k">&amp;&amp;</span> n.size <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> },
  <span class="pl-c1">favourite_foods:</span> set_of(<span class="pl-vo">Symbol</span>),
  <span class="pl-c1">children_by_age:</span> hash_of(<span class="pl-vo">Integer</span> =&gt; <span class="pl-vo">String</span>)
}}

<span class="pl-s3">RSchema</span>.validate(schema, {
  <span class="pl-c1">fname:</span> <span class="pl-s1"><span class="pl-pds">'</span>Johnny<span class="pl-pds">'</span></span>,
  <span class="pl-c1">favourite_foods:</span> <span class="pl-s3">Set</span>.<span class="pl-k">new</span>([<span class="pl-c1">:bacon</span>, <span class="pl-c1">:cheese</span>, <span class="pl-c1">:onion</span>]),
  <span class="pl-c1">children_by_age:</span> {
    <span class="pl-c1">7</span> =&gt; <span class="pl-s1"><span class="pl-pds">'</span>Jenny<span class="pl-pds">'</span></span>,
    <span class="pl-c1">5</span> =&gt; <span class="pl-s1"><span class="pl-pds">'</span>Simon<span class="pl-pds">'</span></span>
  }
}) <span class="pl-c">#=&gt; true</span></pre></div>

<h2>
<a id="when-validation-fails" class="anchor" href="#when-validation-fails" aria-hidden="true"><span class="octicon octicon-link"></span></a>When Validation Fails</h2>

<p>Using <code>RSchema.validate</code>, it is often difficult to tell exactly which values
are failing validation.</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema <span class="pl-k">do</span>
  [
    {
      <span class="pl-c1">name:</span> <span class="pl-vo">String</span>,
      <span class="pl-c1">hair:</span> enum([<span class="pl-c1">:red</span>, <span class="pl-c1">:brown</span>, <span class="pl-c1">:blonde</span>, <span class="pl-c1">:black</span>])
    }
  ]
<span class="pl-k">end</span>

value <span class="pl-k">=</span> [
  { <span class="pl-c1">name:</span> <span class="pl-s1"><span class="pl-pds">'</span>Dane<span class="pl-pds">'</span></span>, <span class="pl-c1">hair:</span> <span class="pl-c1">:black</span> },
  { <span class="pl-c1">name:</span> <span class="pl-s1"><span class="pl-pds">'</span>Tom<span class="pl-pds">'</span></span>, <span class="pl-c1">hair:</span> <span class="pl-c1">:brown</span> },
  { <span class="pl-c1">name:</span> <span class="pl-s1"><span class="pl-pds">'</span>Effie<span class="pl-pds">'</span></span>, <span class="pl-c1">hair:</span> <span class="pl-c1">:blond</span> },
  { <span class="pl-c1">name:</span> <span class="pl-s1"><span class="pl-pds">'</span>Chris<span class="pl-pds">'</span></span>, <span class="pl-c1">hair:</span> <span class="pl-c1">:red</span> },
]

<span class="pl-s3">RSchema</span>.validate(schema, value) <span class="pl-c">#=&gt; false</span></pre></div>

<p>To see exactly where validation fails, we can look at an
<code>RSchema::ErrorDetails</code> object.</p>

<p>The <code>validate!</code> method throws an exception when validation fails, and the
exception contains the <code>RSchema::ErrorDetails</code> object.</p>

<div class="highlight highlight-ruby"><pre><span class="pl-s3">RSchema</span>.validate!(schema, value) <span class="pl-c"># throws exception:</span>
<span class="pl-c">#=&gt; RSchema::ValidationError: The value at [2, :hair] is not a valid enum member: :blond</span></pre></div>

<p>The error above says that the value <code>:blond</code>, which exists at location
<code>value[2][:hair]</code>, is not a valid enum member. Looking back at the schema, we
see that there is a typo, and it should be <code>:blonde</code> instead of <code>:blond</code>.</p>

<p>To get an <code>RSchema::ErrorDetails</code> object <em>without</em> using exceptions, we can use
the <code>RSchema.validation_error</code> method.</p>

<div class="highlight highlight-ruby"><pre>error_details <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.validation_error(schema, value)

error_details.failing_value <span class="pl-c">#=&gt; :blond</span>
error_details.reason <span class="pl-c">#=&gt; "is not a valid enum member"</span>
error_details.key_path <span class="pl-c">#=&gt; [2, :hair]</span>
error_details.to_s <span class="pl-c">#=&gt; "The value at [2, :hair] is not a valid enum member: :blond"</span></pre></div>

<h2>
<a id="array-schemas" class="anchor" href="#array-schemas" aria-hidden="true"><span class="octicon octicon-link"></span></a>Array Schemas</h2>

<p>There are two types of array schemas. When the array schema has a single
element, it is a variable-length array schema:</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> [<span class="pl-vo">Symbol</span>]
<span class="pl-s3">RSchema</span>.validate(schema, [<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>, <span class="pl-c1">:c</span>]) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, [<span class="pl-c1">:a</span>]) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, []) <span class="pl-c">#=&gt; true</span></pre></div>

<p>Otherwise, it is a fixed-length array schema</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> [<span class="pl-vo">Integer</span>, <span class="pl-vo">String</span>]
<span class="pl-s3">RSchema</span>.validate(schema, [<span class="pl-c1">10</span>, <span class="pl-s1"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span>]) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, [<span class="pl-c1">10</span>, <span class="pl-s1"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>world<span class="pl-pds">'</span></span>]) <span class="pl-c">#=&gt; false</span>
<span class="pl-s3">RSchema</span>.validate(schema, [<span class="pl-c1">10</span>]) <span class="pl-c">#=&gt; false</span></pre></div>

<h2>
<a id="hash-schemas" class="anchor" href="#hash-schemas" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hash Schemas</h2>

<p>Hash schemas map constant keys to subschema values:</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> { <span class="pl-c1">fname:</span> <span class="pl-vo">String</span> }
<span class="pl-s3">RSchema</span>.validate(schema, { <span class="pl-c1">fname:</span> <span class="pl-s1"><span class="pl-pds">'</span>William<span class="pl-pds">'</span></span> }) <span class="pl-c">#=&gt; true</span></pre></div>

<p>Keys can be optional:</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema {{
  <span class="pl-c1">:fname</span> =&gt; <span class="pl-vo">String</span>,
  _?(<span class="pl-c1">:age</span>) =&gt; <span class="pl-vo">Integer</span>
}}
<span class="pl-s3">RSchema</span>.validate(schema, { <span class="pl-c1">fname:</span> <span class="pl-s1"><span class="pl-pds">'</span>Lucy<span class="pl-pds">'</span></span>, <span class="pl-c1">age:</span> <span class="pl-c1">21</span> }) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, { <span class="pl-c1">fname:</span> <span class="pl-s1"><span class="pl-pds">'</span>Tom<span class="pl-pds">'</span></span> }) <span class="pl-c">#=&gt; true</span></pre></div>

<p>There is also another type of hash schema that represents hashes with variable
keys:</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema { hash_of(<span class="pl-vo">String</span> =&gt; <span class="pl-vo">Integer</span>) }
<span class="pl-s3">RSchema</span>.validate(schema, { <span class="pl-s1"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span> =&gt; <span class="pl-c1">1</span>, <span class="pl-s1"><span class="pl-pds">'</span>world<span class="pl-pds">'</span></span> =&gt; <span class="pl-c1">2</span> }) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, { <span class="pl-s1"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span> =&gt; <span class="pl-c1">1</span> }) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, {}) <span class="pl-c">#=&gt; true</span></pre></div>

<h2>
<a id="other-schema-types" class="anchor" href="#other-schema-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Other Schema Types</h2>

<p>RSchema provides a few other schema types through its DSL:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># boolean</span>
boolean_schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema{ boolean }
<span class="pl-s3">RSchema</span>.validate(boolean_schema, <span class="pl-c1">false</span>) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(boolean_schema, <span class="pl-c1">nil</span>) <span class="pl-c">#=&gt; false</span>

<span class="pl-c"># maybe</span>
maybe_schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema{ maybe(<span class="pl-vo">Integer</span>) }
<span class="pl-s3">RSchema</span>.validate(maybe_schema, <span class="pl-c1">5</span>) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(maybe_schema, <span class="pl-c1">nil</span>) <span class="pl-c">#=&gt; true</span>

<span class="pl-c"># enum</span>
enum_schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema{ enum([<span class="pl-c1">:a</span>, <span class="pl-c1">:b</span>, <span class="pl-c1">:c</span>]) }
<span class="pl-s3">RSchema</span>.validate(enum_schema, <span class="pl-c1">:a</span>) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(enum_schema, <span class="pl-c1">:z</span>) <span class="pl-c">#=&gt; false</span>

<span class="pl-c"># predicate</span>
predicate_schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema <span class="pl-k">do</span>
  predicate(<span class="pl-s1"><span class="pl-pds">'</span>even<span class="pl-pds">'</span></span>) { |<span class="pl-vo">x</span>| x.even? }
<span class="pl-k">end</span>
<span class="pl-s3">RSchema</span>.validate(predicate_schema, <span class="pl-c1">4</span>) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(predicate_schema, <span class="pl-c1">5</span>) <span class="pl-c">#=&gt; false</span></pre></div>

<h2>
<a id="coercion" class="anchor" href="#coercion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Coercion</h2>

<p>RSchema is capable of coercing invalid values into valid ones, in some
situations. Here are some examples:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-s3">RSchema</span>.coerce!(<span class="pl-vo">Symbol</span>, <span class="pl-s1"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) <span class="pl-c">#=&gt; :hello</span>
<span class="pl-s3">RSchema</span>.coerce!(<span class="pl-vo">String</span>, <span class="pl-c1">:hello</span>)  <span class="pl-c">#=&gt; "hello"</span>
<span class="pl-s3">RSchema</span>.coerce!(<span class="pl-vo">Integer</span>, <span class="pl-s1"><span class="pl-pds">"</span>5<span class="pl-pds">"</span></span>)    <span class="pl-c">#=&gt; 5</span>
<span class="pl-s3">RSchema</span>.coerce!(<span class="pl-vo">Integer</span>, <span class="pl-s1"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span>)  <span class="pl-c"># !!! raises RSchema::ValidationError !!!</span>
<span class="pl-s3">RSchema</span>.coerce!(<span class="pl-vo">Set</span>, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>])  <span class="pl-c">#=&gt; &lt;Set: {1, 2, 3}&gt;</span>

schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema {{
  <span class="pl-c1">fname:</span> <span class="pl-vo">String</span>,
  <span class="pl-c1">favourite_foods:</span> set_of(<span class="pl-vo">Symbol</span>)
}}

value <span class="pl-k">=</span> {
  <span class="pl-c1">fname:</span> <span class="pl-s1"><span class="pl-pds">'</span>Peggy<span class="pl-pds">'</span></span>,
  <span class="pl-c1">favourite_foods:</span> [<span class="pl-s1"><span class="pl-pds">'</span>berries<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>cake<span class="pl-pds">'</span></span>]
}

<span class="pl-s3">RSchema</span>.coerce!(schema, value)
  <span class="pl-c">#=&gt; { fname: "Peggy", favourite_foods: &lt;Set: #{:berries, :cake}&gt; }</span></pre></div>

<h2>
<a id="extending-the-dsl" class="anchor" href="#extending-the-dsl" aria-hidden="true"><span class="octicon octicon-link"></span></a>Extending the DSL</h2>

<p>You can create new, custom DSLs that extend the default DSL like so:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">module</span> <span class="pl-en">MyCustomDSL</span>
  <span class="pl-k">extend</span> <span class="pl-s3">RSchema</span>::<span class="pl-s3">DSL</span>::<span class="pl-vo">Base</span>
  <span class="pl-k">def</span> <span class="pl-en">self.positive_and_even</span>(<span class="pl-vpf">type</span>)
    predicate { |<span class="pl-vo">x</span>| x <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> x.even? }
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Pass the custom DSL to <code>RSchema.schema</code> to use it:</p>

<div class="highlight highlight-ruby"><pre>schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema(<span class="pl-vo">MyCustomDSL</span>) { positive_and_even }
<span class="pl-s3">RSchema</span>.validate(schema, <span class="pl-c1">6</span>)  <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, <span class="pl-k">-</span><span class="pl-c1">6</span>) <span class="pl-c">#=&gt; false</span></pre></div>

<h2>
<a id="custom-schema-types" class="anchor" href="#custom-schema-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Custom Schema Types</h2>

<p>Any Ruby object can be a schema, as long as it implements the <code>schema_walk</code>
method.  Here is a schema called <code>Coordinate</code>, which is an x/y pair of <code>Float</code>s
in an array:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># make the schema type class</span>
<span class="pl-k">class</span> <span class="pl-en">CoordinateSchema</span>
  <span class="pl-k">def</span> <span class="pl-en">schema_walk</span>(<span class="pl-vpf">value</span>, <span class="pl-vpf">mapper</span>)
    <span class="pl-c"># validate `value`</span>
    <span class="pl-k">return</span> <span class="pl-s3">RSchema</span>::<span class="pl-s3">ErrorDetails</span>.<span class="pl-k">new</span>(value, <span class="pl-s1"><span class="pl-pds">'</span>is not an Array<span class="pl-pds">'</span></span>) <span class="pl-k">unless</span> value.is_a?(<span class="pl-vo">Array</span>)
    <span class="pl-k">return</span> <span class="pl-s3">RSchema</span>::<span class="pl-s3">ErrorDetails</span>.<span class="pl-k">new</span>(value, <span class="pl-s1"><span class="pl-pds">'</span>does not have two elements<span class="pl-pds">'</span></span>) <span class="pl-k">unless</span> value.size <span class="pl-k">==</span> <span class="pl-c1">2</span>

    <span class="pl-c"># walk the subschemas/subvalues</span>
    x, x_error <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.walk(<span class="pl-vo">Float</span>, value[<span class="pl-c1">0</span>], mapper)
    y, y_error <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.walk(<span class="pl-vo">Float</span>, value[<span class="pl-c1">1</span>], mapper)

    <span class="pl-c"># look for subschema errors, and propagate them if found</span>
    <span class="pl-k">return</span> x_error.extend_key_path(<span class="pl-c1">:x</span>) <span class="pl-k">if</span> x_error
    <span class="pl-k">return</span> y_error.extend_key_path(<span class="pl-c1">:y</span>) <span class="pl-k">if</span> y_error

    <span class="pl-c"># return the valid value</span>
    [x, y]
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c"># add some DSL</span>
<span class="pl-k">module</span> <span class="pl-en"><span class="pl-e">RSchema::</span>DSL</span>
  <span class="pl-k">def</span> <span class="pl-en">self.coordinate</span>
    <span class="pl-s3">CoordinateSchema</span>.<span class="pl-k">new</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c"># use the custom schema type (coercion works too)</span>
schema <span class="pl-k">=</span> <span class="pl-s3">RSchema</span>.schema { coordinate }
<span class="pl-s3">RSchema</span>.validate(schema, [<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>]) <span class="pl-c">#=&gt; true</span>
<span class="pl-s3">RSchema</span>.validate(schema, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>]) <span class="pl-c">#=&gt; false</span>
<span class="pl-s3">RSchema</span>.coerce!(schema, [<span class="pl-s1"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>]) <span class="pl-c">#=&gt; [1.0, 2.0]</span></pre></div>

<p>The <code>schema_walk</code> method receives two arguments:</p>

<ul>
<li>
<code>value</code>: the value that is being validated against this schema</li>
<li>
<code>mapper</code>: not usually used by the schema, but must be passed to
<code>RSchema.walk</code>.</li>
</ul>

<p>The <code>schema_walk</code> method has three responsibilities:</p>

<ol>
<li><p>It must validate the given value. If the value is invalid, the method must
return an <code>RSchema::ErrorDetails</code> object. If the value is valid, it must
return the valid value after walking all subvalues.</p></li>
<li><p>For composite schemas, it must walk subvalues by calling <code>RSchema.walk</code>.
The example above walks two subvalues (<code>value[0]</code> and <code>value[1]</code>) with the
<code>Float</code> schema.</p></li>
<li><p>It must propagate any <code>RSchema::ErrorDetails</code> objects returned from walking
the subvalues. Walking subvalues with <code>RSchema.walk</code> may return an error,
in which case the <code>rschema_walk</code> method must also return an error. Use the
method <code>RSchema::ErrorDetails#extend_key_path</code> in this situation, to
include additional information in the error before returning it.</p></li>
</ol>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/tomdalling/rschema/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/tomdalling/rschema/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/tomdalling/rschema"></a> is maintained by <a href="https://github.com/tomdalling">tomdalling</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-2797451-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
