{"name":"RSchema","tagline":"Schema-based validation and coercion for Ruby data structures","body":"# RSchema\r\n\r\nSchema-based validation and coercion for Ruby data structures. Heavily inspired\r\nby (read: stolen from) [Prismatic/schema][] for Clojure.\r\n\r\nMeet RSchema\r\n------------\r\n\r\nA \"schema\" is a data structure that describes the _shape_ of data.\r\nSchemas are generally just plain old hashes, arrays, and classes.\r\n\r\n```ruby\r\npost_schema = {\r\n  title: String,\r\n  tags: [Symbol],\r\n  body: String\r\n}\r\n```\r\n\r\nSchemas can be used to validate data. That is, they can check whether\r\ndata is in the correct shape:\r\n\r\n```ruby\r\nRSchema.validate!(post_schema, {\r\n  title: \"You won't beleive how this developer foo'd her bar\",\r\n  tags: [:foos, :bars, :unbeleivable],\r\n  body: '<p>blah blah</p>'\r\n}) # ok\r\n```\r\n\r\nWhat is a schema?\r\n-----------------\r\n\r\nSchemas are Ruby data structures. The simplest type of schema is just a class:\r\n\r\n```ruby\r\nschema = Integer\r\nRSchema.validate!(schema, 5)       # ok\r\nRSchema.validate!(schema, 'hello') # !!! raises RSchema::ValidationError !!!\r\n```\r\n\r\nThen there are composite schemas, which are schemas composed of subschemas.\r\nArrays are composite schemas:\r\n\r\n```ruby\r\nschema = [Integer]\r\nRSchema.validate!(schema, [10, 11, 12])   # ok\r\nRSchema.validate!(schema, [10, 11, '12']) # !!! raises RSchema::ValidationError !!!\r\n```\r\n\r\nAnd so are hashes:\r\n\r\n```ruby\r\nschema = { fname: String, age: Integer }\r\nRSchema.validate!(schema, { fname: 'Jane', age: 27 }) # ok\r\nRSchema.validate!(schema, { fname: 'Johnny' })        # !!! raises RSchema::ValidationError !!!\r\n```\r\n\r\nWhile schemas are just plain old Ruby data structures, RSchema also provides\r\nan extensible DSL for constructing more complicated schemas:\r\n\r\n```ruby\r\nschema = RSchema.schema {{\r\n  fname: predicate { |n| n.is_a?(String) && n.size > 0 },\r\n  favourite_foods: set_of(Symbol),\r\n  children_by_age: hash_of(Integer => String)\r\n}}\r\n\r\nRSchema.validate!(schema, {\r\n  fname: 'Johnny',\r\n  favourite_foods: Set.new([:bacon, :cheese, :onion]),\r\n  children_by_age: {\r\n    7 => 'Jenny',\r\n    5 => 'Simon'\r\n  }\r\n}) # ok\r\n```\r\n\r\nArray Schemas\r\n-------------\r\n\r\nThere are two types of array schemas. When the array schema has a single\r\nelement, it is a variable-length array schema:\r\n\r\n```ruby\r\nschema = [Symbol]\r\nRSchema.validate!(schema, [:a, :b, :c]) # ok\r\nRSchema.validate!(schema, [:a])         # ok\r\nRSchema.validate!(schema, [])           # ok\r\n```\r\n\r\nOtherwise, it is a fixed-length array schema\r\n\r\n```ruby\r\nschema = [Integer, String]\r\nRSchema.validate!(schema, [10, 'hello'])          # ok\r\nRSchema.validate!(schema, [10, 'hello', 'world']) # !!! raises RSchema::ValidationError !!!\r\nRSchema.validate!(schema, [10])                   # !!! raises RSchema::ValidationError !!!\r\n```\r\n\r\nHash Schemas\r\n------------\r\n\r\nHash schemas map constant keys to subschema values:\r\n\r\n```ruby\r\nschema = { fname: String }\r\nRSchema.validate!(schema, { fname: 'William' }) # ok\r\n```\r\n\r\nKeys can be optional:\r\n\r\n```ruby\r\nschema = RSchema.schema {{\r\n  :fname => String,\r\n  _?(:age) => Integer\r\n}}\r\nRSchema.validate!(schema, { fname: 'Lucy', age: 21 }) # ok\r\nRSchema.validate!(schema, { fname: 'Tom' })           # ok\r\n```\r\n\r\nThere is also another type of hash schema that represents hashes with variable\r\nkeys:\r\n\r\n```ruby\r\nschema = RSchema.schema { hash_of(String => Integer) }\r\nRSchema.validate!(schema, { 'hello' => 1, 'world' => 2 }) # ok\r\nRSchema.validate!(schema, { 'hello' => 1 })               # ok\r\nRSchema.validate!(schema, {})                             # ok\r\n```\r\n\r\nOther Schema Types\r\n------------------\r\n\r\nRSchema provides a few other schema types through its DSL:\r\n\r\n```ruby\r\n# boolean\r\nboolean_schema = RSchema.schema{ boolean }\r\nRSchema.validate!(boolean_schema, false) # ok\r\nRSchema.validate!(boolean_schema, nil) # !!! raises RSchema::ValidationError !!!\r\n\r\n# maybe\r\nmaybe_schema = RSchema.schema{ maybe(Integer) }\r\nRSchema.validate!(maybe_schema, 5)   # ok\r\nRSchema.validate!(maybe_schema, nil) # ok\r\n\r\n# enum\r\nenum_schema = RSchema.schema{ enum([:a, :b, :c]) }\r\nRSchema.validate!(enum_schema, :a) # ok\r\nRSchema.validate!(enum_schema, :z) # !!! raises RSchema::ValidationError !!!\r\n\r\n# predicate\r\npredicate_schema = RSchema.schema do\r\n  predicate('even') { |x| x.even? }\r\nend\r\nRSchema.validate!(predicate_schema, 4) # ok\r\nRSchema.validate!(predicate_schema, 5) # !!! raises RSchema::ValidationError !!!\r\n```\r\n\r\nCoercion\r\n--------\r\n\r\nRSchema is capable of coercing invalid values into valid ones, in some\r\nsituations. Here are some examples:\r\n\r\n```ruby\r\nRSchema.coerce!(Symbol, \"hello\") #=> :hello\r\nRSchema.coerce!(String, :hello)  #=> \"hello\"\r\nRSchema.coerce!(Integer, \"5\")    #=> 5\r\nRSchema.coerce!(Integer, \"cat\")  # !!! raises RSchema::ValidationError !!!\r\nRSchema.coerce!(Set, [1, 2, 3])  #=> <Set: {1, 2, 3}>\r\n\r\nschema = RSchema.schema {{\r\n  fname: String,\r\n  favourite_foods: set_of(Symbol)\r\n}}\r\n\r\nvalue = {\r\n  fname: 'Peggy',\r\n  favourite_foods: ['berries', 'cake']\r\n}\r\n\r\nRSchema.coerce!(schema, value)\r\n  #=> { fname: \"Peggy\", favourite_foods: <Set: #{:berries, :cake}> }\r\n```\r\n\r\nExtending the DSL\r\n-----------------\r\n\r\nThe RSchema DSL can be extended by adding methods to the `RSchema::DSL` module:\r\n\r\n```ruby\r\nmodule RSchema::DSL\r\n  def self.positive_and_even(type)\r\n    predicate { |x| x > 0 && x.even? }\r\n  end\r\nend\r\n\r\nschema = RSchema.schema { positive_and_even }\r\nRSchema.validate!(schema, 6)  # ok\r\nRSchema.validate!(schema, -6) # !!! raises RSchema::ValidationError !!!\r\n```\r\n\r\nCustom Schema Types\r\n-------------------\r\n\r\nAny Ruby object can be a schema, as long as it implements the `schema_walk`\r\nmethod.  Here is a schema called `Coordinate`, which is an x/y pair of `Float`s\r\nin an array:\r\n\r\n```ruby\r\n# make the schema type class\r\nclass CoordinateSchema\r\n  def schema_walk(value, mapper)\r\n    # validate `value`\r\n    return RSchema::ErrorDetails.new('is not an Array') unless value.is_a?(Array)\r\n    return RSchema::ErrorDetails.new('does not have two elements') unless value.size == 2\r\n\r\n    # walk the subschemas/subvalues\r\n    x, x_error = RSchema.walk(Float, value[0], mapper)\r\n    y, y_error = RSchema.walk(Float, value[1], mapper)\r\n\r\n    # look for subschema errors, and propagate them if found\r\n    return RSchema::ErrorDetails.new({ x: x_error.details }) if x_error\r\n    return RSchema::ErrorDetails.new({ y: y_error.details }) if y_error\r\n\r\n    # return the valid value\r\n    [x, y]\r\n  end\r\nend\r\n\r\n# add some DSL\r\nmodule RSchema::DSL\r\n  def self.coordinate\r\n    CoordinateSchema.new\r\n  end\r\nend\r\n\r\n# use the custom schema type (coercion works too)\r\nschema = RSchema.schema { coordinate }\r\nRSchema.validate!(schema, [1.0, 2.0]) # ok\r\nRSchema.validate!(schema, [1, 2])     # !!! raises RSchema::ValidationError !!!\r\nRSchema.coerce!(schema, [\"1\", \"2\"])   #=> [1.0, 2.0]\r\n```\r\n\r\nThe `schema_walk` method receives two arguments:\r\n\r\n - `value`: the value that is being validated against this schema\r\n - `mapper`: not usually used by the schema, but must be passed to\r\n   `RSchema.walk`.\r\n\r\nThe `schema_walk` method has three responsibilities:\r\n\r\n 1. It must validate the given value. If the value is invalid, the method must\r\n    return an `RSchema::ErrorDetails` object. If the value is valid, it must\r\n    return the valid value after walking all subvalues.\r\n\r\n 2. For composite schemas, it must walk subvalues by calling `RSchema.walk`.\r\n    The example above walks two subvalues (`value[0]` and `value[1]`) with the\r\n    `Float` schema.\r\n\r\n 3. It must propagate any `RSchema::ErrorDetails` objects returned from walking\r\n    the subvalues. Walking subvalues with `RSchema.walk` may return an error,\r\n    in which case the `rschema_walk` method must also return an error.\r\n\r\n[Prismatic/schema]: https://github.com/Prismatic/schema\r\n\r\n","google":"UA-2797451-1","note":"Don't delete this file! It's used internally to help with page regeneration."}