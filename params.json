{"name":"RSchema","tagline":"Schema-based validation and coercion for Ruby data structures","body":"# RSchema\r\n\r\nSchema-based validation and coercion for Ruby data structures. Heavily inspired\r\nby (read: stolen from) [Prismatic/schema][] for Clojure.\r\n\r\nMeet RSchema\r\n------------\r\n\r\nA \"schema\" is a data structure that describes the _shape_ of data.\r\nSchemas are generally just plain old hashes, arrays, and classes.\r\n\r\n```ruby\r\npost_schema = {\r\n  title: String,\r\n  tags: [Symbol],\r\n  body: String\r\n}\r\n```\r\n\r\nSchemas can be used to validate data. That is, they can check whether\r\ndata is in the correct shape:\r\n\r\n```ruby\r\nRSchema.validate(post_schema, {\r\n  title: \"You won't beleive how this developer foo'd her bar\",\r\n  tags: [:foos, :bars, :unbeleivable],\r\n  body: '<p>blah blah</p>'\r\n}) #=> true\r\n```\r\n\r\nWhat is a schema?\r\n-----------------\r\n\r\nSchemas are Ruby data structures. The simplest type of schema is just a class:\r\n\r\n```ruby\r\nschema = Integer\r\nRSchema.validate(schema, 5) #=> true\r\nRSchema.validate(schema, 'hello') #=> false\r\n```\r\n\r\nThen there are composite schemas, which are schemas composed of subschemas.\r\nArrays are composite schemas:\r\n\r\n```ruby\r\nschema = [Integer]\r\nRSchema.validate(schema, [10, 11, 12]) #=> true\r\nRSchema.validate(schema, [10, 11, '12']) #=> false\r\n```\r\n\r\nAnd so are hashes:\r\n\r\n```ruby\r\nschema = { fname: String, age: Integer }\r\nRSchema.validate(schema, { fname: 'Jane', age: 27 }) #=> true\r\nRSchema.validate(schema, { fname: 'Johnny' }) #=> false\r\n```\r\n\r\nWhile schemas are just plain old Ruby data structures, RSchema also provides\r\nan extensible DSL for constructing more complicated schemas:\r\n\r\n```ruby\r\nschema = RSchema.schema {{\r\n  fname: predicate { |n| n.is_a?(String) && n.size > 0 },\r\n  favourite_foods: set_of(Symbol),\r\n  children_by_age: hash_of(Integer => String)\r\n}}\r\n\r\nRSchema.validate(schema, {\r\n  fname: 'Johnny',\r\n  favourite_foods: Set.new([:bacon, :cheese, :onion]),\r\n  children_by_age: {\r\n    7 => 'Jenny',\r\n    5 => 'Simon'\r\n  }\r\n}) #=> true\r\n```\r\n\r\nWhen Validation Fails\r\n---------------------\r\n\r\nUsing `RSchema.validate`, it is often difficult to tell exactly which values\r\nare failing validation.\r\n\r\n```ruby\r\nschema = RSchema.schema do\r\n  [\r\n    {\r\n      name: String,\r\n      hair: enum([:red, :brown, :blonde, :black])\r\n    }\r\n  ]\r\nend\r\n\r\nvalue = [\r\n  { name: 'Dane', hair: :black },\r\n  { name: 'Tom', hair: :brown },\r\n  { name: 'Effie', hair: :blond },\r\n  { name: 'Chris', hair: :red },\r\n]\r\n\r\nRSchema.validate(schema, value) #=> false\r\n```\r\n\r\nTo see exactly where validation fails, we can look at an\r\n`RSchema::ErrorDetails` object.\r\n\r\nThe `validate!` method throws an exception when validation fails, and the\r\nexception contains the `RSchema::ErrorDetails` object.\r\n\r\n```ruby\r\nRSchema.validate!(schema, value) # throws exception:\r\n#=> RSchema::ValidationError: The value at [2, :hair] is not a valid enum member: :blond\r\n```\r\n\r\nThe error above says that the value `:blond`, which exists at location\r\n`value[2][:hair]`, is not a valid enum member. Looking back at the schema, we\r\nsee that there is a typo, and it should be `:blonde` instead of `:blond`.\r\n\r\nTo get an `RSchema::ErrorDetails` object _without_ using exceptions, we can use\r\nthe `RSchema.validation_error` method.\r\n\r\n```ruby\r\nerror_details = RSchema.validation_error(schema, value)\r\n\r\nerror_details.failing_value #=> :blond\r\nerror_details.reason #=> \"is not a valid enum member\"\r\nerror_details.key_path #=> [2, :hair]\r\nerror_details.to_s #=> \"The value at [2, :hair] is not a valid enum member: :blond\"\r\n```\r\n\r\nArray Schemas\r\n-------------\r\n\r\nThere are two types of array schemas. When the array schema has a single\r\nelement, it is a variable-length array schema:\r\n\r\n```ruby\r\nschema = [Symbol]\r\nRSchema.validate(schema, [:a, :b, :c]) #=> true\r\nRSchema.validate(schema, [:a]) #=> true\r\nRSchema.validate(schema, []) #=> true\r\n```\r\n\r\nOtherwise, it is a fixed-length array schema\r\n\r\n```ruby\r\nschema = [Integer, String]\r\nRSchema.validate(schema, [10, 'hello']) #=> true\r\nRSchema.validate(schema, [10, 'hello', 'world']) #=> false\r\nRSchema.validate(schema, [10]) #=> false\r\n```\r\n\r\nHash Schemas\r\n------------\r\n\r\nHash schemas map constant keys to subschema values:\r\n\r\n```ruby\r\nschema = { fname: String }\r\nRSchema.validate(schema, { fname: 'William' }) #=> true\r\n```\r\n\r\nKeys can be optional:\r\n\r\n```ruby\r\nschema = RSchema.schema {{\r\n  :fname => String,\r\n  _?(:age) => Integer\r\n}}\r\nRSchema.validate(schema, { fname: 'Lucy', age: 21 }) #=> true\r\nRSchema.validate(schema, { fname: 'Tom' }) #=> true\r\n```\r\n\r\nThere is also another type of hash schema that represents hashes with variable\r\nkeys:\r\n\r\n```ruby\r\nschema = RSchema.schema { hash_of(String => Integer) }\r\nRSchema.validate(schema, { 'hello' => 1, 'world' => 2 }) #=> true\r\nRSchema.validate(schema, { 'hello' => 1 }) #=> true\r\nRSchema.validate(schema, {}) #=> true\r\n```\r\n\r\nOther Schema Types\r\n------------------\r\n\r\nRSchema provides a few other schema types through its DSL:\r\n\r\n```ruby\r\n# boolean\r\nboolean_schema = RSchema.schema{ boolean }\r\nRSchema.validate(boolean_schema, false) #=> true\r\nRSchema.validate(boolean_schema, nil) #=> false\r\n\r\n# maybe\r\nmaybe_schema = RSchema.schema{ maybe(Integer) }\r\nRSchema.validate(maybe_schema, 5) #=> true\r\nRSchema.validate(maybe_schema, nil) #=> true\r\n\r\n# enum\r\nenum_schema = RSchema.schema{ enum([:a, :b, :c]) }\r\nRSchema.validate(enum_schema, :a) #=> true\r\nRSchema.validate(enum_schema, :z) #=> false\r\n\r\n# predicate\r\npredicate_schema = RSchema.schema do\r\n  predicate('even') { |x| x.even? }\r\nend\r\nRSchema.validate(predicate_schema, 4) #=> true\r\nRSchema.validate(predicate_schema, 5) #=> false\r\n```\r\n\r\nCoercion\r\n--------\r\n\r\nRSchema is capable of coercing invalid values into valid ones, in some\r\nsituations. Here are some examples:\r\n\r\n```ruby\r\nRSchema.coerce!(Symbol, \"hello\") #=> :hello\r\nRSchema.coerce!(String, :hello)  #=> \"hello\"\r\nRSchema.coerce!(Integer, \"5\")    #=> 5\r\nRSchema.coerce!(Integer, \"cat\")  # !!! raises RSchema::ValidationError !!!\r\nRSchema.coerce!(Set, [1, 2, 3])  #=> <Set: {1, 2, 3}>\r\n\r\nschema = RSchema.schema {{\r\n  fname: String,\r\n  favourite_foods: set_of(Symbol)\r\n}}\r\n\r\nvalue = {\r\n  fname: 'Peggy',\r\n  favourite_foods: ['berries', 'cake']\r\n}\r\n\r\nRSchema.coerce!(schema, value)\r\n  #=> { fname: \"Peggy\", favourite_foods: <Set: #{:berries, :cake}> }\r\n```\r\n\r\nExtending the DSL\r\n-----------------\r\n\r\nYou can create new, custom DSLs that extend the default DSL like so:\r\n\r\n```ruby\r\nmodule MyCustomDSL\r\n  extend RSchema::DSL::Base\r\n  def self.positive_and_even(type)\r\n    predicate { |x| x > 0 && x.even? }\r\n  end\r\nend\r\n```\r\n\r\nPass the custom DSL to `RSchema.schema` to use it:\r\n\r\n```ruby\r\nschema = RSchema.schema(MyCustomDSL) { positive_and_even }\r\nRSchema.validate(schema, 6)  #=> true\r\nRSchema.validate(schema, -6) #=> false\r\n```\r\n\r\nCustom Schema Types\r\n-------------------\r\n\r\nAny Ruby object can be a schema, as long as it implements the `schema_walk`\r\nmethod.  Here is a schema called `Coordinate`, which is an x/y pair of `Float`s\r\nin an array:\r\n\r\n```ruby\r\n# make the schema type class\r\nclass CoordinateSchema\r\n  def schema_walk(value, mapper)\r\n    # validate `value`\r\n    return RSchema::ErrorDetails.new(value, 'is not an Array') unless value.is_a?(Array)\r\n    return RSchema::ErrorDetails.new(value, 'does not have two elements') unless value.size == 2\r\n\r\n    # walk the subschemas/subvalues\r\n    x, x_error = RSchema.walk(Float, value[0], mapper)\r\n    y, y_error = RSchema.walk(Float, value[1], mapper)\r\n\r\n    # look for subschema errors, and propagate them if found\r\n    return x_error.extend_key_path(:x) if x_error\r\n    return y_error.extend_key_path(:y) if y_error\r\n\r\n    # return the valid value\r\n    [x, y]\r\n  end\r\nend\r\n\r\n# add some DSL\r\nmodule RSchema::DSL\r\n  def self.coordinate\r\n    CoordinateSchema.new\r\n  end\r\nend\r\n\r\n# use the custom schema type (coercion works too)\r\nschema = RSchema.schema { coordinate }\r\nRSchema.validate(schema, [1.0, 2.0]) #=> true\r\nRSchema.validate(schema, [1, 2]) #=> false\r\nRSchema.coerce!(schema, [\"1\", \"2\"]) #=> [1.0, 2.0]\r\n```\r\n\r\nThe `schema_walk` method receives two arguments:\r\n\r\n - `value`: the value that is being validated against this schema\r\n - `mapper`: not usually used by the schema, but must be passed to\r\n   `RSchema.walk`.\r\n\r\nThe `schema_walk` method has three responsibilities:\r\n\r\n 1. It must validate the given value. If the value is invalid, the method must\r\n    return an `RSchema::ErrorDetails` object. If the value is valid, it must\r\n    return the valid value after walking all subvalues.\r\n\r\n 2. For composite schemas, it must walk subvalues by calling `RSchema.walk`.\r\n    The example above walks two subvalues (`value[0]` and `value[1]`) with the\r\n    `Float` schema.\r\n\r\n 3. It must propagate any `RSchema::ErrorDetails` objects returned from walking\r\n    the subvalues. Walking subvalues with `RSchema.walk` may return an error,\r\n    in which case the `rschema_walk` method must also return an error. Use the\r\n    method `RSchema::ErrorDetails#extend_key_path` in this situation, to\r\n    include additional information in the error before returning it.\r\n\r\n[Prismatic/schema]: https://github.com/Prismatic/schema\r\n\r\n","google":"UA-2797451-1","note":"Don't delete this file! It's used internally to help with page regeneration."}